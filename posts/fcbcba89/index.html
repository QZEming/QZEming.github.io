<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <link rel="shortcut icon" href="/img/assets/favicon.ico">
        <link href="https://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">
        
<link rel="stylesheet" href="/css/style.css">

            <title>
                前端小黑
            </title>
<meta name="generator" content="Hexo 4.2.0"></head>

    <body>
        <header id="header" class="header">
    <div class="avatarContainer">
        <h1 class="blogName">
            前端小黑
        </h1>
    </div>
    <nav class="topNav">
    
        <a href=/  class=>
                    首页
                </a>
        
        <a href=/about  class=>
                    关于
                </a>
        
        <a href=/archives  class=>
                    归档
                </a>
        
        <a href=https://github.com/QZEming  class=>
                    GITHUB
                </a>
        
        <a href=https://blog.csdn.net/zemprogram/  class=>
                    CSDN
                </a>
        
            <img src="/img/assets/code.png" alt="avatar">
</nav>
</header>
            <div class="mainContainer">
                <aside class="aside">
    <div class="info asideContainer">
    <div class="imgContainer">
        <img src=/img/assets/logo.png alt="作者头像">
    </div>
    <div class="authorInfo">
        <p class="authorName">
            前端小黑
        </p>
        <p class="subtitle">
            学习它不香吗
        </p>
        <p class="description">
            想成为小黑的前端小白的博客
        </p>
        <p class="keywords">
            
                <span class="keyword">前端</span>
                
                <span class="keyword">算法</span>
                
                <span class="keyword">计算机网络</span>
                
        </p>
    </div>
</div>
        <div class="tags asideContainer">
    <h3 class="asideTitle">
        标签
    </h3>
    <div class="asideContent">
        
            <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6+</a><span class="article-tag-list-count">3</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="article-tag-list-count">3</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96/" rel="tag">JavaScript模块化</a><span class="article-tag-list-count">5</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/axios/" rel="tag">axios</a><span class="article-tag-list-count">1</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="article-tag-list-count">1</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a><span class="article-tag-list-count">6</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">react学习笔记</a><span class="article-tag-list-count">6</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="article-tag-list-count">3</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">前端工程化</a><span class="article-tag-list-count">1</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a><span class="article-tag-list-count">2</span></li></ul>
                
    </div>
</div>
            <div class="categories asideContainer">
    <h3 class="asideTitle">
        categories
    </h3>
    <div class="asideContent">
        
            <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/categories/JavaScript/">JavaScript</a><span class="article-tag-list-count">11</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/categories/react/">react</a><span class="article-tag-list-count">6</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/categories/vue/">vue</a><span class="article-tag-list-count">1</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a><span class="article-tag-list-count">1</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><span class="article-tag-list-count">4</span></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="article-tag-list-count">2</span></li></ul>
                
    </div>
</div>
</aside>
                    <main class="main">
    
        <article class="articleContainer">
    <h1 class="articleTitle">
        <span>JavaScript模块化（二）CommonJS</span>
    </h1>
    <div class="articleContent">
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr>
<p>CommonJS提出JavaScript不仅针对浏览器，它做为一个规范，在服务器端被广泛使用，最常见到的就是node中的使用<br>事实上，node就是基于CommonJS规范来写的，在CommonJS规范中，每个js文件作为一个模块，CommonJS在服务器端和浏览器端的加载是不一样的</p>
<a id="more"></a>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><hr>
<h2 id="暴露模块"><a href="#暴露模块" class="headerlink" title="暴露模块"></a>暴露模块</h2><p>在CommonJS规范中，我们通过module.exports和exports.xxx来暴露模块内部的变量和方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = val  <br>exports.key = val<br></code></pre></td></tr></table></figure>
<p><strong>暴露本质</strong>：暴露出exports对象<br>对于module.exports来说，等同于将等号后面的内容覆盖原来的exports对象<br>而对于exports.xxx来说，就是在exports对象上增添属性<br>对于上面那两行代码来说，本质上就是:</p>
<ul>
<li>module.exports = val：将val赋值给exports对象，结果就是exports=val</li>
<li>exports.key = val：将val赋值给exports对象的key属性，若没有就新建该属性，结果就是exports={key : val}</li>
</ul>
<p>通过本质可以看出</p>
<ul>
<li>module.exports因为会修改整个exports对象，所以重复写会使得后写的覆盖先写的，而exports.xxx只会不断添加属性，除非xxx是相同的，否则就可以一直叠加下去</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>    foo()&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>);<br>    &#125;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    bar()&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar'</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这里，后写的module.exports会把之前的module.exports覆盖掉，exports对象将只剩一个bar方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">exports.foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>);<br>&#125;<br>exports.bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'bar'</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而这里的exports.xxx则会使得暴露出去的exports对象同时有foo和bar方法<br>此外，要注意的是，CommonJS输出的内容是值的拷贝，也即是说在导入模块后，修改模块方法并不会影响到原有的模块的内容</p>
<h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><p>require(xxx)<br>第三方模块：直接使用模块名<br>如下面使用node创建服务器，就直接引用了http模块（代码来自<a href="https://nodejs.org/en/about/" target="_blank" rel="noopener">node官网</a>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// node创建服务器的代码</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);<br><br><span class="hljs-keyword">const</span> hostname = <span class="hljs-string">'127.0.0.1'</span>;<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.statusCode = <span class="hljs-number">200</span>;<br>  res.setHeader(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'text/plain'</span>);<br>  res.end(<span class="hljs-string">'Hello World\n'</span>);<br>&#125;);<br><br>server.listen(port, hostname, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Server running at http://<span class="hljs-subst">$&#123;hostname&#125;</span>:<span class="hljs-subst">$&#123;port&#125;</span>/`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>自定义模块：使用文件路径，后缀名默认为js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// module.js</span><br>exports.foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>);<br>&#125;<br><span class="hljs-comment">// mian.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./module.js'</span>)<br><span class="hljs-built_in">module</span>.foo()<br></code></pre></td></tr></table></figure>
<p>使用require时要注意相对路径的写法</p>
<ul>
<li>‘/xxx’ ：表示根目录的xxx文件；</li>
<li>‘./xxx’ ：表示和当前文件同一文件夹下的xxx文件；</li>
<li>‘../xxx’ ：表示当前文件的上级目录的xxx文件；</li>
<li>’xxx’：表示要在node_modules寻找相应的模块<h1 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h1></li>
</ul>
<hr>
<h2 id="不同端的加载方式"><a href="#不同端的加载方式" class="headerlink" title="不同端的加载方式"></a>不同端的加载方式</h2><p>在服务器端模块的加载是<strong>同步</strong>的：可能出现阻塞<br>在浏览器端模块需要<strong>提前编译打包处理</strong>，即使请求发送到了服务端，但是之前的模块还没加载好，所以客户端会一直等待<br>正因其加载的不同，CommonJS更适合在服务器端使用，在服务器中同步加载，只要将所有导入都放在模块（文件）顶部（至少要放在使用该模块相应内容的上一行），我们就可以保证在引用其他模块的方法前已经加载好这些模块，而对于浏览器环境来说，我们不知道网络情况如何，如果我们发起了一个异步请求，而这些模块还没加载好的时候我们执行了接下来的代码，而这些代码里面又需要这个模块的方法，那就会报错<br>就如下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>)<br><span class="hljs-keyword">var</span> _body = $(<span class="hljs-string">'body'</span>)<br></code></pre></td></tr></table></figure>
<p>在浏览器环境下，如果jquery模块还没加载好，那么$(‘body’)就会报错，所以在浏览器中不适合使用CommonJS规范<br>此外，浏览器不认识require，需要提前处理语法，可以通过使用browserify打包来处理</p>
<h2 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h2><p>在Node下加载模块时，Node会将加载的模块缓存下来，在下次请求该模块时直接丛缓存中获取该模块，所以多次使用require实际上只会请求一次模块</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><hr>
<ul>
<li>服务端：Node</li>
<li>浏览器端：需要进行打包，可以使用<strong>browserify</strong>打包<br>browserify需要在全局安装后再在本地安装才能使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm i browserify -g<br>npm i browserify<br></code></pre></td></tr></table></figure>
安装后通过browserify命令打包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">browserify main.js -o bundle.js<br></code></pre></td></tr></table></figure>
main.js是要打包的文件，bundle.js是打包生成的文件</li>
</ul>

    </div>
</article>
            
</main>
                        
                            <aside class="articleDirectory">
    <h2 class="asideTitle">目录</h2>
    <div class="asideContainer">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本语法"><span class="toc-number">2.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暴露模块"><span class="toc-number">2.1.</span> <span class="toc-text">暴露模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引入模块"><span class="toc-number">2.2.</span> <span class="toc-text">引入模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#加载机制"><span class="toc-number">3.</span> <span class="toc-text">加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#不同端的加载方式"><span class="toc-number">3.1.</span> <span class="toc-text">不同端的加载方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块缓存"><span class="toc-number">3.2.</span> <span class="toc-text">模块缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用"><span class="toc-number">4.</span> <span class="toc-text">使用</span></a></li></ol>
    </div>
</aside>
                                
            </div>
            <footer class="footer">
    <p>Site by <a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a> | theme <a>simp</a></p>
</footer>
                <div class="backTop icon-arrow-up hideBtn" id="backTop"></div>
                
                    <script src="/js/highlight.js"></script>
                    <script>
                        hljs.initHighlightingOnLoad();
                    </script>
                    
                        <script src="/js/script.js"></script>
    </body>

</html>